import {
  require_three
} from "./chunk-KGXG3V5R.js";
import {
  __commonJS
} from "./chunk-76J2PTFD.js";

// node_modules/@ar-js-org/ar.js/three.js/build/ar-threex-location-only.js
var require_ar_threex_location_only = __commonJS({
  "node_modules/@ar-js-org/ar.js/three.js/build/ar-threex-location-only.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e(require_three()) : "function" == typeof define && define.amd ? define(["three"], e) : "object" == typeof exports ? exports.THREEx = e(require_three()) : t.THREEx = e(t.THREE);
    }(exports, (t) => (() => {
      "use strict";
      var e = { 381: (e2) => {
        e2.exports = t;
      } }, i = {};
      function o(t2) {
        var n2 = i[t2];
        if (void 0 !== n2)
          return n2.exports;
        var s = i[t2] = { exports: {} };
        return e[t2](s, s.exports, o), s.exports;
      }
      o.d = (t2, e2) => {
        for (var i2 in e2)
          o.o(e2, i2) && !o.o(t2, i2) && Object.defineProperty(t2, i2, { enumerable: true, get: e2[i2] });
      }, o.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), o.r = (t2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      };
      var n = {};
      return (() => {
        o.r(n), o.d(n, { DeviceOrientationControls: () => l, LocationBased: () => i2, WebcamRenderer: () => s });
        class t2 {
          constructor() {
            this.EARTH = 4007501668e-2, this.HALF_EARTH = 2003750834e-2;
          }
          project(t3, e3) {
            return [this.lonToSphMerc(t3), this.latToSphMerc(e3)];
          }
          unproject(t3) {
            return [this.sphMercToLon(t3[0]), this.sphMercToLat(t3[1])];
          }
          lonToSphMerc(t3) {
            return t3 / 180 * this.HALF_EARTH;
          }
          latToSphMerc(t3) {
            return Math.log(Math.tan((90 + t3) * Math.PI / 360)) / (Math.PI / 180) * this.HALF_EARTH / 180;
          }
          sphMercToLon(t3) {
            return t3 / this.HALF_EARTH * 180;
          }
          sphMercToLat(t3) {
            var e3 = t3 / this.HALF_EARTH * 180;
            return 180 / Math.PI * (2 * Math.atan(Math.exp(e3 * Math.PI / 180)) - Math.PI / 2);
          }
          getID() {
            return "epsg:3857";
          }
        }
        var e2 = o(381);
        class i2 {
          constructor(e3, i3, o2 = {}) {
            this._scene = e3, this._camera = i3, this._proj = new t2(), this._eventHandlers = {}, this._lastCoords = null, this._gpsMinDistance = 0, this._gpsMinAccuracy = 100, this._maximumAge = 0, this._watchPositionId = null, this.setGpsOptions(o2), this.initialPosition = null, this.initialPositionAsOrigin = o2.initialPositionAsOrigin || false;
          }
          setProjection(t3) {
            this._proj = t3;
          }
          setGpsOptions(t3 = {}) {
            void 0 !== t3.gpsMinDistance && (this._gpsMinDistance = t3.gpsMinDistance), void 0 !== t3.gpsMinAccuracy && (this._gpsMinAccuracy = t3.gpsMinAccuracy), void 0 !== t3.maximumAge && (this._maximumAge = t3.maximumAge);
          }
          startGps(t3 = 0) {
            return null === this._watchPositionId && (this._watchPositionId = navigator.geolocation.watchPosition((t4) => {
              this._gpsReceived(t4);
            }, (t4) => {
              this._eventHandlers.gpserror ? this._eventHandlers.gpserror(t4.code) : alert(`GPS error: code ${t4.code}`);
            }, { enableHighAccuracy: true, maximumAge: 0 != t3 ? t3 : this._maximumAge }), true);
          }
          stopGps() {
            return null !== this._watchPositionId && (navigator.geolocation.clearWatch(this._watchPositionId), this._watchPositionId = null, true);
          }
          fakeGps(t3, e3, i3 = null, o2 = 0) {
            null !== i3 && this.setElevation(i3), this._gpsReceived({ coords: { longitude: t3, latitude: e3, accuracy: o2 } });
          }
          lonLatToWorldCoords(t3, e3) {
            const i3 = this._proj.project(t3, e3);
            if (this.initialPositionAsOrigin) {
              if (!this.initialPosition)
                throw "Trying to use 'initial position as origin' mode with no initial position determined";
              i3[0] -= this.initialPosition[0], i3[1] -= this.initialPosition[1];
            }
            return [i3[0], -i3[1]];
          }
          add(t3, e3, i3, o2) {
            this.setWorldPosition(t3, e3, i3, o2), this._scene.add(t3);
          }
          setWorldPosition(t3, e3, i3, o2) {
            const n2 = this.lonLatToWorldCoords(e3, i3);
            void 0 !== o2 && (t3.position.y = o2), [t3.position.x, t3.position.z] = n2;
          }
          setElevation(t3) {
            this._camera.position.y = t3;
          }
          on(t3, e3) {
            this._eventHandlers[t3] = e3;
          }
          setWorldOrigin(t3, e3) {
            this.initialPosition = this._proj.project(t3, e3);
          }
          _gpsReceived(t3) {
            let e3 = Number.MAX_VALUE;
            t3.coords.accuracy <= this._gpsMinAccuracy && (null === this._lastCoords ? this._lastCoords = { latitude: t3.coords.latitude, longitude: t3.coords.longitude } : e3 = this._haversineDist(this._lastCoords, t3.coords), e3 >= this._gpsMinDistance && (this._lastCoords.longitude = t3.coords.longitude, this._lastCoords.latitude = t3.coords.latitude, this.initialPositionAsOrigin && !this.initialPosition && this.setWorldOrigin(t3.coords.longitude, t3.coords.latitude), this.setWorldPosition(this._camera, t3.coords.longitude, t3.coords.latitude), this._eventHandlers.gpsupdate && this._eventHandlers.gpsupdate(t3, e3)));
          }
          _haversineDist(t3, i3) {
            const o2 = e2.MathUtils.degToRad(i3.longitude - t3.longitude), n2 = e2.MathUtils.degToRad(i3.latitude - t3.latitude), s2 = Math.sin(n2 / 2) * Math.sin(n2 / 2) + Math.cos(e2.MathUtils.degToRad(t3.latitude)) * Math.cos(e2.MathUtils.degToRad(i3.latitude)) * (Math.sin(o2 / 2) * Math.sin(o2 / 2));
            return 2 * Math.atan2(Math.sqrt(s2), Math.sqrt(1 - s2)) * 6371e3;
          }
        }
        class s {
          constructor(t3, i3) {
            let o2;
            this.renderer = t3, this.renderer.autoClear = false, this.sceneWebcam = new e2.Scene(), void 0 === i3 ? (o2 = document.createElement("video"), o2.setAttribute("autoplay", true), o2.setAttribute("playsinline", true), o2.style.display = "none", document.body.appendChild(o2)) : o2 = document.querySelector(i3), this.geom = new e2.PlaneBufferGeometry(), this.texture = new e2.VideoTexture(o2), this.material = new e2.MeshBasicMaterial({ map: this.texture });
            const n2 = new e2.Mesh(this.geom, this.material);
            if (this.sceneWebcam.add(n2), this.cameraWebcam = new e2.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, 0, 10), navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
              const t4 = { video: { width: 1280, height: 720, facingMode: "environment" } };
              navigator.mediaDevices.getUserMedia(t4).then((t5) => {
                console.log("using the webcam successfully..."), o2.srcObject = t5, o2.play();
              }).catch((t5) => {
                setTimeout(() => {
                  this.createErrorPopup("Webcam Error\nName: " + t5.name + "\nMessage: " + t5.message);
                }, 1e3);
              });
            } else
              setTimeout(() => {
                this.createErrorPopup("sorry - media devices API not supported");
              }, 1e3);
          }
          update() {
            this.renderer.clear(), this.renderer.render(this.sceneWebcam, this.cameraWebcam), this.renderer.clearDepth();
          }
          dispose() {
            this.material.dispose(), this.texture.dispose(), this.geom.dispose();
          }
          createErrorPopup(t3) {
            if (!document.getElementById("error-popup")) {
              var e3 = document.createElement("div");
              e3.innerHTML = t3, e3.setAttribute("id", "error-popup"), document.body.appendChild(e3);
            }
          }
        }
        const r = new e2.Vector3(0, 0, 1), a = new e2.Euler(), h = new e2.Quaternion(), c = new e2.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)), d = { type: "change" };
        class l extends e2.EventDispatcher {
          constructor(t3) {
            super(), false === window.isSecureContext && console.error("THREE.DeviceOrientationControls: DeviceOrientationEvent is only available in secure contexts (https)");
            const i3 = this, o2 = new e2.Quaternion();
            this.object = t3, this.object.rotation.reorder("YXZ"), this.enabled = true, this.deviceOrientation = {}, this.screenOrientation = 0, this.alphaOffset = 0, this.TWO_PI = 2 * Math.PI, this.HALF_PI = 0.5 * Math.PI, this.orientationChangeEventName = "ondeviceorientationabsolute" in window ? "deviceorientationabsolute" : "deviceorientation", this.smoothingFactor = 1;
            const n2 = function(t4) {
              i3.deviceOrientation = t4;
            }, s2 = function() {
              i3.screenOrientation = window.orientation || 0;
            };
            this.connect = function() {
              s2(), void 0 !== window.DeviceOrientationEvent && "function" == typeof window.DeviceOrientationEvent.requestPermission ? window.DeviceOrientationEvent.requestPermission().then((t4) => {
                "granted" === t4 && (window.addEventListener("orientationchange", s2), window.addEventListener(i3.orientationChangeEventName, n2));
              }).catch(function(t4) {
                console.error("THREE.DeviceOrientationControls: Unable to use DeviceOrientation API:", t4);
              }) : (window.addEventListener("orientationchange", s2), window.addEventListener(i3.orientationChangeEventName, n2)), i3.enabled = true;
            }, this.disconnect = function() {
              window.removeEventListener("orientationchange", s2), window.removeEventListener(i3.orientationChangeEventName, n2), i3.enabled = false;
            }, this.update = function() {
              if (false === i3.enabled)
                return;
              const t4 = i3.deviceOrientation;
              if (t4) {
                let n3 = t4.alpha ? e2.MathUtils.degToRad(t4.alpha) + i3.alphaOffset : 0, s3 = t4.beta ? e2.MathUtils.degToRad(t4.beta) : 0, l2 = t4.gamma ? e2.MathUtils.degToRad(t4.gamma) : 0;
                const u = i3.screenOrientation ? e2.MathUtils.degToRad(i3.screenOrientation) : 0;
                if (this.smoothingFactor < 1) {
                  if (this.lastOrientation) {
                    const t5 = this.smoothingFactor;
                    n3 = this._getSmoothedAngle(n3, this.lastOrientation.alpha, t5), s3 = this._getSmoothedAngle(s3 + Math.PI, this.lastOrientation.beta, t5), l2 = this._getSmoothedAngle(l2 + this.HALF_PI, this.lastOrientation.gamma, t5, Math.PI);
                  } else
                    s3 += Math.PI, l2 += this.HALF_PI;
                  this.lastOrientation = { alpha: n3, beta: s3, gamma: l2 };
                }
                !function(t5, e3, i4, o3, n4) {
                  a.set(i4, e3, -o3, "YXZ"), t5.setFromEuler(a), t5.multiply(c), t5.multiply(h.setFromAxisAngle(r, -n4));
                }(i3.object.quaternion, n3, this.smoothingFactor < 1 ? s3 - Math.PI : s3, this.smoothingFactor < 1 ? l2 - this.HALF_PI : l2, u), 8 * (1 - o2.dot(i3.object.quaternion)) > 1e-6 && (o2.copy(i3.object.quaternion), i3.dispatchEvent(d));
              }
            }, this._orderAngle = function(t4, e3, i4 = this.TWO_PI) {
              return e3 > t4 && Math.abs(e3 - t4) < i4 / 2 || t4 > e3 && Math.abs(e3 - t4) > i4 / 2 ? { left: t4, right: e3 } : { left: e3, right: t4 };
            }, this._getSmoothedAngle = function(t4, e3, i4, o3 = this.TWO_PI) {
              const n3 = this._orderAngle(t4, e3, o3), s3 = n3.left, r2 = n3.right;
              n3.left = 0, n3.right -= s3, n3.right < 0 && (n3.right += o3);
              let a2 = r2 == e3 ? (1 - i4) * n3.right + i4 * n3.left : i4 * n3.right + (1 - i4) * n3.left;
              return a2 += s3, a2 >= o3 && (a2 -= o3), a2;
            }, this.dispose = function() {
              i3.disconnect();
            }, this.connect();
          }
        }
      })(), n;
    })());
  }
});

export {
  require_ar_threex_location_only
};
//# sourceMappingURL=chunk-BTTDCNGE.js.map
